<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>힙합 랭겜 추첨기</title>
  <link rel="icon" href="./assets/favicon.ico">
  <style>
    /* ====== 참여자 팝업 전용 리셋/레이아웃 ====== */
    #rankModal{
      position:fixed; inset:0;
      display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.55); z-index:9998; padding:24px;
    }
    #rankModal.show{ display:flex; }
  
    #rankModal .modal-card{
      background:#fff; width:95vw; max-width:1100px; max-height:85vh;
      border-radius:14px; box-shadow:0 18px 40px rgba(0,0,0,.35);
      display:flex; flex-direction:column; overflow:hidden;
    }
    #rankModal .modal-header{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 16px; border-bottom:1px solid #eaeef2;
    }
    #rankModal .modal-title{ font-weight:800; font-size:18px; }
    #rankModal .modal-close{
      appearance:none; border:0; background:transparent; cursor:pointer;
      font-size:22px; line-height:1; padding:8px 10px;
    }
  
    /* 팝업 본문 = 스크롤 컨테이너 (세로/가로 모두) */
    #rankModal .modal-body{
      position:relative; background:#fff;
      padding:10px 14px; max-height:85vh; overflow:auto;
    }
  
    /* ====== 테이블 (폭 계산 안정화 & 고정 헤더/첫열) ====== */
    #rankModal .table-wrap{ min-width:100%; }        /* 컨테이너 폭은 채우고… */
  
    #rankModal table{
      border-collapse:separate; border-spacing:0;
      width:100%;                 /* 기본은 컨테이너 폭을 채움 */
      table-layout:auto;          /* 내용에 맞게, 단 아래 nowrap로 과도 확장 방지 */
      font-size:14px; margin:0;
    }
    #rankModal th, #rankModal td{
      box-sizing:border-box;      /* 스크롤바/보더 오차 방지 */
      border:1px solid #e1e4e8;
      padding:8px 10px; text-align:left;
      white-space:nowrap;         /* 줄바꿈 금지 → 가로 스크롤로 처리 */
      background:#fff; background-clip:padding-box;
    }
  
    /* 상단 헤더 고정 */
    #rankModal thead th{
      position:sticky; top:0; z-index:3;
      background:#f6f8fa; box-shadow:0 1px 0 rgba(0,0,0,.04);
    }
  
    /* 좌측 첫 열(이름) 고정: 헤더/바디 모두 */
    #rankModal thead th:first-child,
    #rankModal tbody td:first-child{
      position:sticky; left:0; z-index:4; background:#fff;
    }
    /* 첫 열이 헤더인 경우 배경 톤 유지 + 경계 그림자 */
    #rankModal thead th:first-child{
      background:#f6f8fa; box-shadow:1px 0 0 rgba(0,0,0,.06), 0 1px 0 rgba(0,0,0,.04);
    }
    /* 바디의 첫 열에도 살짝 경계 그림자 */
    #rankModal tbody td:first-child{ box-shadow:1px 0 0 rgba(0,0,0,.06); }
  
    /* ‘승리’ 열 오른쪽 굵은 구분선(클래스가 붙어오는 경우) */
    #rankModal th.sep-right, #rankModal td.sep-right{
      border-right-width:3px !important; border-right-color:#1f2a44 !important;
    }
  
    /* 1회/2회/...에서 승 표기 강조(클래스가 붙어오는 경우) */
    #rankModal td.extra-col.win-cell{ background:#fff8d6; }
  
    /* 작은 화면 대응 */
    @media (max-width:640px){
      #rankModal .modal-card{ width:98vw; }
      #rankModal .modal-body{ padding:8px 10px; }
    }
  </style>
</head>
<body class="notranslate">
  <h2>힙합 랭겜 추첨기</h2>
  <!-- 시트 열기 -->
  <div class="actions">
    <button class="btn" id="open-sheet-btn">시트 열기</button>
  </div>
  <div id="status">⏳ 부팅 중…</div>
  <div id="meta"></div>

  <div class="grid">
    <div class="card">
      <div class="title" data-rank="언랭"><span>언랭</span><span class="sub">(지원/참여/승리)</span></div>
      <div id="count-언랭" class="count">(당첨: 0명 / 남음: 0명)</div>
      <div id="box-언랭" class="box"></div>
      <div>
        <button id="btn-언랭" onclick="pick('언랭')" disabled>뽑기!</button>
        <button id="reset-언랭" onclick="resetRank('언랭')" disabled>리셋</button>
      </div>
    </div>

    <div class="card">
      <div class="title" data-rank="브론즈"><span>브론즈</span><span class="sub">(지원/참여/승리)</span></div>
      <div id="count-브론즈" class="count">(당첨: 0명 / 남음: 0명)</div>
      <div id="box-브론즈" class="box"></div>
      <div>
        <button id="btn-브론즈" onclick="pick('브론즈')" disabled>뽑기!</button>
        <button id="reset-브론즈" onclick="resetRank('브론즈')" disabled>리셋</button>
      </div>
    </div>

    <div class="card">
      <div class="title" data-rank="실버"><span>실버</span><span class="sub">(지원/참여/승리)</span></div>
      <div id="count-실버" class="count">(당첨: 0명 / 남음: 0명)</div>
      <div id="box-실버" class="box"></div>
      <div>
        <button id="btn-실버" onclick="pick('실버')" disabled>뽑기!</button>
        <button id="reset-실버" onclick="resetRank('실버')" disabled>리셋</button>
      </div>
    </div>

    <div class="card">
      <div class="title" data-rank="골드"><span>골드</span><span class="sub">(지원/참여/승리)</span></div>
      <div id="count-골드" class="count">(당첨: 0명 / 남음: 0명)</div>
      <div id="box-골드" class="box"></div>
      <div>
        <button id="btn-골드" onclick="pick('골드')" disabled>뽑기!</button>
        <button id="reset-골드" onclick="resetRank('골드')" disabled>리셋</button>
      </div>
    </div>
  </div>

  <div style="margin:10px 0 8px;">
    <button id="copy-btn" class="btn" onclick="copyWinners()" disabled>클립보드로 복사</button>
  </div>

  <!-- 추첨 오버레이 -->
  <div id="overlay">
    <div class="panel">
      <div id="tierChip" class="chip"></div>
      <div id="canvasWrap"><canvas id="wheelCanvas" width="560" height="200"></canvas></div>
    </div>
  </div>

  <!-- 랭크 팝업 -->
  <div id="rankModal">
    <div class="modal-card" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title" id="rankModalTitle">참여자 리스트</div>
        <button class="modal-close" id="rankModalClose" aria-label="닫기">✕</button>
      </div>
      <div class="modal-body">
        <div id="rankTableWrap"></div>
      </div>
    </div>
  </div>

  <!-- 효과음: 결과 시점에만 재생 -->
  <audio id="ding" src="./assets/ding.mp3" preload="none"></audio>

<script>
/* ===== 설정(GAS 웹앱) — /exec URL로 교체 ===== */
const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbxXag4ZYrj1ttorbmcyEiZY_b82fVqNAI7RPWfukrQe4hxBnSTU2rCJyX_xVp4wIiDgsw/exec';
let SHEET_ID_FROM_GAS = null;

/* ===== 전역 상태 ===== */
const RANKS=['언랭','브론즈','실버','골드'];
let pool={언랭:[],브론즈:[],실버:[],골드:[]};
let selected={언랭:[],브론즈:[],실버:[],골드:[]};
let memberStats={};
/* 참여자 리스트 원본 테이블 */
let statsHeader = [];
let statsRows   = [];

/* ===== helpers ===== */
const $=id=>document.getElementById(id);
const setStatus=(m,e)=>{const el=$('status'); if(!el) return; el.className=e?'status-err':'status-ok'; el.textContent=m;};
const html=(id,h)=>{const el=$(id); if(el) el.innerHTML=h;};
const append=(id,h)=>{const el=$(id); if(el) el.insertAdjacentHTML('beforeend',h);};
const dis=(id,v)=>{const el=$(id); if(el) el.disabled=!!v;};
const esc=s=>String(s).replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
function fmtStats(name){ const st=memberStats[name]||{apply:0,part:0,win:0}; return `${st.apply||0}/${st.part||0}/${st.win||0}`; }
function renderRow(name){ const safe=esc(name); return `<div class="winner-row"><span class="winner-name"><b>${safe}</b></span><span class="winner-stats">(${fmtStats(name)})</span></div>`; }
function updateCounts(rank){ const p=(selected[rank]||[]).length; const r=Math.max(0,(pool[rank]?.length||0)-p); html('count-'+rank,`(당첨: ${p}명 / 남음: ${r}명)`); }
function totalWinners(){return RANKS.reduce((s,r)=>s+(selected[r]?.length||0),0)}
function copyWinners(){ if(totalWinners()===0){ setStatus('복사할 당첨자가 없습니다.',true); return; }
  const lines=[]; for(const r of RANKS){ const arr=selected[r]||[]; if(!arr.length) continue; lines.push(r,'------------',...arr.map(n=>`${n}`),''); }
  const txt=lines.join('\n').trim(); if(navigator.clipboard?.writeText){ navigator.clipboard.writeText(txt).then(()=>setStatus('✅ 복사 완료',false)).catch(()=>alert(txt)); } else alert(txt);
}
function _norm(s){ return String(s||'').replace(/\u00A0/g,' ').replace(/\s+/g,' ').trim(); }
function rankNorm(s){ s=_norm(s).toLowerCase(); if(/언랭|unrank/.test(s))return '언랭'; if(/브론즈|bronze/.test(s))return '브론즈'; if(/실버|silver/.test(s))return '실버'; if(/골드|gold/.test(s))return '골드'; return ''; }

/* ===== 스피너 ===== */
function gradByRank(rank){ switch(rank){ case '브론즈':return 'linear-gradient(135deg,#968768,#524937)'; case '실버':return 'linear-gradient(135deg,#BABABA,#616060)'; case '골드':return 'linear-gradient(135deg,#D1C432,#827810)'; default:return 'linear-gradient(135deg,#44D446,#2C472C)'; } }
function setupCanvas(canvas){ const dpr=Math.max(1,window.devicePixelRatio||1); const rect=canvas.getBoundingClientRect(); canvas.style.width=rect.width+'px'; canvas.style.height=rect.height+'px'; canvas.width=Math.round(rect.width*dpr); canvas.height=Math.round(rect.height*dpr); const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0); ctx.imageSmoothingEnabled=true; return { ctx, w:rect.width, h:rect.height }; }
function drawName(ctx, text, cx, cy, maxW, targetH, weight=900){ let lo=14, hi=Math.min(targetH,64), best=lo; ctx.save(); ctx.textBaseline='middle'; ctx.textAlign='center'; while(lo<=hi){ const mid=(lo+hi)>>1; ctx.font=`normal ${weight} ${mid}px Arial, "Noto Sans KR", sans-serif`; const w=ctx.measureText(text).width; if(w<=maxW){best=mid; lo=mid+1;} else hi=mid-1; } ctx.font=`normal ${weight} ${best}px Arial, "Noto Sans KR", sans-serif`; ctx.fillText(text,Math.round(cx)+0.5,Math.round(cy)+0.5); ctx.restore(); }
let LAST_SPIN_MODE=null;
function pickStopMode(){
  const modes=['exact','nudgeForward','nudgeBackward'];
  return modes[(Math.random()*3)|0]; // 균등 1/3
}
function canvasSpin(names, winner, opts, onDone){
  const overlay=$('overlay'); const canvas=$('wheelCanvas'); const { ctx, w, h }=setupCanvas(canvas);
  const centerY=h/2, rowH=opts.rowH||40, gap=opts.gap||12, step=rowH+gap;
  const accelMs=opts.accelMs??500, steadyMs=opts.steadyMs??900, decelMs=opts.decelMs??1100;
  const shakeMs=260, nudgeMs=300, shakeAmp=8; const easeOutCubic=t=>1-Math.pow(1-t,3);
  const L=Math.max(1,names.length), startIdx=Math.floor(Math.random()*L), winIdx=names.indexOf(winner);
  const mode=pickStopMode(); let preIdx=winIdx, nudgeDir=0; if(mode==='nudgeForward'){ preIdx=(winIdx-1+L)%L; nudgeDir=+1; } if(mode==='nudgeBackward'){ preIdx=(winIdx+1)%L; nudgeDir=-1; }
  const cycles=4, idxDiffPre=((preIdx-startIdx)%L+L)%L, baseTotalShift=(cycles*L+idxDiffPre)*step;
  const spinTotal=accelMs+steadyMs+decelMs, extraTotal=(nudgeDir===0?0:(shakeMs+nudgeMs));
  function drawCenterGuides(){ ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.18)'; ctx.lineWidth=1; const pad=12, yA=Math.round(centerY-step/2)+0.5, yB=Math.round(centerY+step/2)+0.5; ctx.beginPath(); ctx.moveTo(pad,yA); ctx.lineTo(w-pad,yA); ctx.moveTo(pad,yB); ctx.lineTo(w-pad,yB); ctx.stroke(); ctx.restore(); }
  function renderFrame(now,t0){ const t=now-t0; let dist=0;
    if(t<=spinTotal){ if(t<=accelMs){ dist=baseTotalShift*(t/accelMs*0.2); } else if(t<=accelMs+steadyMs){ dist=baseTotalShift*(0.2+0.5*((t-accelMs)/steadyMs)); } else { dist=baseTotalShift*(0.7+0.3*easeOutCubic(Math.min(1,(t-accelMs-steadyMs)/decelMs))); } }
    else if(nudgeDir!==0 && t<=spinTotal+shakeMs){ dist=baseTotalShift+Math.sin(((t-spinTotal)/shakeMs)*Math.PI*2.0)*shakeAmp; }
    else if(nudgeDir!==0 && t<=spinTotal+shakeMs+nudgeMs){ dist=baseTotalShift+(nudgeDir*step)*easeOutCubic(Math.min(1,(t-spinTotal-shakeMs)/nudgeMs)); }
    else { dist=baseTotalShift+(nudgeDir*step); }
    ctx.clearRect(0,0,w,h); const shiftRows=dist/step, baseIdx=Math.floor(shiftRows), frac=shiftRows-baseIdx;
    for(let k=-3;k<=+3;k++){ const idx=(startIdx+baseIdx+k+L)%L; const name=names[idx]; const y=centerY-(k-frac)*step; const ady=Math.abs(k-frac);
      let scale=0.6, alpha=0.45; if(ady<=0.5){ scale=1.0; alpha=1.0; } else if(ady<=1.5){ scale=0.8; alpha=0.75; }
      ctx.save(); ctx.globalAlpha=alpha; if(scale>=0.95){ ctx.shadowColor='rgba(0,0,0,0.55)'; ctx.shadowBlur=10; ctx.shadowOffsetY=3; } else { ctx.shadowColor='transparent'; ctx.shadowBlur=0; ctx.shadowOffsetY=0; }
      ctx.fillStyle='#fff'; drawName(ctx, name, w/2, y, w*0.86, rowH*scale, 900); ctx.restore();
    }
    drawCenterGuides();
    const endTime=spinTotal+extraTotal;
    if(t<endTime){ requestAnimationFrame(n2=>renderFrame(n2,t0)); }
    else {
      try{ const ding=$('ding'); if(ding){ ding.currentTime=0; ding.play().catch(()=>{}); } }catch(e){}
      setTimeout(()=>{ $('overlay').classList.remove('show'); onDone&&onDone(); }, opts.waitMs ?? 1800);
    }
  }
  requestAnimationFrame(t0=>renderFrame(t0,t0));
}
function showOverlayWithName(rank, winner, done){
  const names=(pool[rank]||[]).map(s=>String(s||'').trim()).filter(Boolean);
  $('overlay').style.setProperty('--grad', gradByRank(rank));
  $('tierChip').textContent=(rank==='브론즈'?'BRONZE':rank==='실버'?'SILVER':rank==='골드'?'GOLD':rank);
  $('overlay').classList.add('show');
  canvasSpin(names.length?names:[winner], String(winner), {accelMs:500,steadyMs:900,decelMs:1100,rowH:40,gap:12,waitMs:1800}, done);
}

/* ===== pick/reset ===== */
function pick(rank){
  try{
    const btn=$('btn-'+rank); if(!btn||btn.disabled) return; btn.disabled=true;
    const remain=(pool[rank]||[]).filter(n=>n && !(selected[rank]||[]).includes(n));
    if(!remain.length){ setStatus(`⚠️ ${rank} 인원이 없습니다.`,true); btn.disabled=false; return; }
    const winner=remain[Math.floor(Math.random()*remain.length)];
    showOverlayWithName(rank, winner, ()=>{
      (selected[rank]=selected[rank]||[]).push(winner);
      append('box-'+rank, renderRow(winner));
      updateCounts(rank);
      const still=(pool[rank]?.length||0)-(selected[rank]?.length||0);
      btn.disabled=(still===0);
      dis('copy-btn', totalWinners()===0);
      setStatus(`${rank} → ${winner} 당첨!`, false);
    });
  }catch(e){ setStatus('❌ pick 오류: '+e,true); }
}
function resetRank(rank){
  selected[rank]=[]; html('box-'+rank,''); updateCounts(rank);
  dis('btn-'+rank,(pool[rank]?.length||0)===0); dis('copy-btn', totalWinners()===0);
  setStatus(`${rank} 리셋 완료`, false);
}
function preReset(){
  setStatus('⏳ 부팅 중…',false); $('meta').textContent='';
  for(const r of RANKS){ html('box-'+r,''); html('count-'+r,'(당첨: 0명 / 남음: 0명)'); dis('btn-'+r,true); dis('reset-'+r,true); }
  dis('copy-btn',true);
}

/* ===== 랭크 팝업 테이블(등급 열 제외) + 고정 헤더 분리 렌더 ===== */
function buildRankTable(rank){
  if(!statsHeader.length){ return '<div>참여자 리스트를 불러오지 못했습니다.</div>'; }
  const hdr = statsHeader.map(h => _norm(h));
  const idxName  = hdr.findIndex(h => /^이름$|^name$/i.test(h));
  const idxRank  = hdr.findIndex(h => /^등급$|^랭크$|^rank$/i.test(h)); // 필터용만
  const idxApply = hdr.findIndex(h => /^지원$|^apply$/i.test(h));
  const idxPart  = hdr.findIndex(h => /^참여$|^part$/i.test(h));
  const idxWin   = hdr.findIndex(h => /^승리$|^win$/i.test(h));
  const extraIdx = []; hdr.forEach((h,i)=>{ if(/^\d+\s*회$/i.test(h)) extraIdx.push(i); });

  const headTitles = [];
  let winColAt = -1;
  if(idxName>=0)  headTitles.push('이름');
  if(idxApply>=0) headTitles.push('지원');
  if(idxPart>=0)  headTitles.push('참여');
  if(idxWin>=0){  winColAt = headTitles.length; headTitles.push('승리'); }
  extraIdx.forEach(i => headTitles.push(hdr[i]));

  const rowsHtml = [];
  for(const r of statsRows){
    const rv = idxRank>=0 ? r[idxRank] : '';
    if(rank && rankNorm(rv)!==rank) continue;
    const tds = [];
    if(idxName>=0)  tds.push(`<td class="sticky-col sticky-col-body">${esc(r[idxName]||'')}</td>`);
    if(idxApply>=0) tds.push(`<td>${esc(r[idxApply]||'')}</td>`);
    if(idxPart>=0)  tds.push(`<td>${esc(r[idxPart ]||'')}</td>`);
    if(idxWin>=0)   tds.push(`<td class="sep-right">${esc(r[idxWin  ]||'')}</td>`);
    extraIdx.forEach(i => {
      const val = String(r[i] ?? '');
      const isWin = /승리?|win/i.test(val);
      tds.push(`<td class="extra-col${isWin?' win-cell':''}">${esc(val)}</td>`);
    });
    rowsHtml.push(`<tr>${tds.join('')}</tr>`);
  }

  const fixedHead = `
    <div class="fixed-head" id="fixedHead">
      ${headTitles.map((t,i)=>`
        <div class="fh-cell ${i===0?'sticky-col-head':''} ${i===winColAt?'sep-right':''}">${esc(t)}</div>
      `).join('')}
    </div>`;

  const table = `
    <div class="table-scroll">
      <table>
        <thead></thead>
        <tbody>${rowsHtml.join('') || '<tr><td>해당 등급 데이터가 없습니다.</td></tr>'}</tbody>
      </table>
    </div>`;

  return fixedHead + table;
}

/* ✅ 고정 헤더 초기화/동기화 (열 너비 계산 + 가로 스크롤 sync) */
function initFixedHead() {
  const wrap = document.getElementById('rankTableWrap');
  if(!wrap) return;
  const modalBody = wrap.closest('.modal-body');
  const fh  = wrap.querySelector('.fixed-head');
  const tbl = wrap.querySelector('table');
  const tbody = tbl?.tBodies?.[0];
  if(!modalBody || !fh || !tbody) return;

  const fhCells = Array.from(fh.children);
  const rows    = Array.from(tbody.rows);
  if(!rows.length || !fhCells.length) return;

  // ── ⛳️ 열 너비 결정(여기가 '너비를 정하는 부분')
  const colCount = Math.min(fhCells.length, rows[0].cells.length);
  const widths = new Array(colCount).fill(0);

  const sample = rows.slice(0, Math.min(40, rows.length));
  for(const tr of sample){
    const cells = tr.cells;
    for(let c=0;c<colCount;c++){
      const w = cells[c]?.getBoundingClientRect().width || 0;
      widths[c] = Math.max(widths[c], Math.ceil(w));
    }
  }
  // 헤더 라벨 폭도 고려(여유 16px)
  for(let c=0;c<colCount;c++){
    const labelW = Math.ceil(fhCells[c].scrollWidth + 16);
    widths[c] = Math.max(widths[c], labelW);
  }
  // 적용
  for(let c=0;c<colCount;c++){
    const w = widths[c] + 'px';
    fhCells[c].style.width = fhCells[c].style.minWidth = fhCells[c].style.maxWidth = w;
  }
  for(const tr of rows){
    const cells = tr.cells;
    for(let c=0;c<colCount;c++){
      const w = widths[c] + 'px';
      const td = cells[c]; if(!td) continue;
      td.style.width = td.style.minWidth = td.style.maxWidth = w;
    }
  }

  // 가로 스크롤 동기화
  function syncX(){ fh.style.transform = `translateX(${-modalBody.scrollLeft}px)`; }
  modalBody.addEventListener('scroll', syncX, {passive:true});
  syncX();

  // 리사이즈/줌 대응
  let t=null;
  const recalc=()=>{ t&&cancelAnimationFrame(t); t=requestAnimationFrame(()=>initFixedHead()); };
  const ro = new ResizeObserver(recalc);
  ro.observe(wrap);
  window.addEventListener('orientationchange', recalc);
}

/* ===== 데이터 로드(GAS) ===== */
async function loadData(){
  try{
    const res = await fetch(GAS_ENDPOINT, { cache: 'no-store' });
    if(!res.ok) throw new Error('GAS endpoint HTTP '+res.status);
    const data = await res.json();

    pool = {
      '언랭': Array.isArray(data.pools?.['언랭']) ? data.pools['언랭'] : [],
      '브론즈': Array.isArray(data.pools?.['브론즈']) ? data.pools['브론즈'] : [],
      '실버': Array.isArray(data.pools?.['실버']) ? data.pools['실버'] : [],
      '골드': Array.isArray(data.pools?.['골드']) ? data.pools['골드'] : []
    };
    memberStats = (data.stats && typeof data.stats==='object') ? data.stats : {};
    statsHeader = Array.isArray(data.statsHeader) ? data.statsHeader : [];
    statsRows   = Array.isArray(data.statsRows)   ? data.statsRows   : [];
    SHEET_ID_FROM_GAS = data.sheetId || null;

    for(const r of RANKS){
      const remain=(pool[r]||[]).length;
      html('count-'+r,`(당첨: 0명 / 남음: ${remain}명)`);
      dis('btn-'+r, remain===0);
      dis('reset-'+r,false);
    }
    dis('copy-btn',true);
    setStatus('✅ 준비 완료', false);
  }catch(e){
    setStatus('❌ 데이터 로드 실패: '+ (e.message||e), true);
    console.error(e);
  }
}

/* ===== 부팅 & 이벤트 바인딩 ===== */
document.addEventListener('DOMContentLoaded', ()=>{
  preReset();
  loadData();

  // 시트 열기
  $('open-sheet-btn').addEventListener('click', ()=>{
    const id = SHEET_ID_FROM_GAS;
    if(!id){ setStatus('시트 ID를 찾을 수 없습니다.', true); return; }
    const url = `https://docs.google.com/spreadsheets/d/${id}/edit`;
    window.open(url, '_blank', 'noopener');
  });

  // 타이틀 클릭 → 랭크 팝업
  document.querySelectorAll('.title[data-rank]').forEach(el=>{
    el.addEventListener('click', ()=>{
      const rank = el.getAttribute('data-rank');
      $('rankModalTitle').textContent = `참여자 리스트 — ${rank}`;
      $('rankTableWrap').innerHTML = buildRankTable(rank);
      $('rankModal').classList.add('show');
      initFixedHead(); // ✅ 고정 헤더 초기화
    });
  });

  // 팝업 닫기
  $('rankModalClose').addEventListener('click', ()=>$('rankModal').classList.remove('show'));
  $('rankModal').addEventListener('click', (e)=>{
    if(e.target.id==='rankModal') $('rankModal').classList.remove('show'); // 바깥 클릭 닫기
  });
});
</script>
</body>
</html>





