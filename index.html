<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>힙합 랭겜 추첨기 · GitHub Pages + Google Sheets</title>
  <!--
    ✅ 이 파일은 Apps Script 없이 GitHub Pages에서 실행되지만,
       데이터는 "공개된" Google Sheets에서 직접 불러옵니다.

    ▷ 시트 공개 방법
      - Google Sheets 상단 메뉴: 파일 → 웹에 게시 (모든 탭(시트)을 게시 권장)
      - 또는 필요한 탭만 개별 게시해도 됨
      - 게시/공개 후 누구나 보기 권한이어야 gviz JSON이 CORS로 열림

    ▷ 이 index.html 은 기존 GAS 버전의 UI/로직을 최대한 유지합니다.
      - 기존 GAS 코드에서 고정 시트 URL은 다음과 같았습니다:
        https://docs.google.com/spreadsheets/d/1Lk99MVmQQjmS-Xq0Otie-Lu7X5bAjcfmoR_uwXlZee4/edit#gid=0  ← (업로더 제공) 
      - 아래 SHEET_ID 로 반영함

    ▷ 참고: 기존 GAS 부트 로직 (google.script.run.healthCheck → loadFixedSheet) 부분은 제거하고,
            fetch + gviz 파싱으로 대체했습니다. (코드 구조/함수명은 기존과 유사)
  -->
  <style>
    :root{ --maxw: 1720px; --card-w: 380px; --box-w: 240px; --box-h: 220px; }
    html,body{margin:0;padding:0;background:transparent !important;overflow:hidden}
    body{font-family:Arial,system-ui,"Noto Sans KR","Malgun Gothic",sans-serif;font-size:18px;text-align:center}
    h2{margin:10px 0 6px}
    #status{min-height:22px;margin:6px 0 2px}
    .status-ok{color:#1a7f37}.status-err{color:#c62828}
    #meta{font-size:13px;color:#666;min-height:18px;margin-bottom:14px}

    .grid{max-width:var(--maxw);margin:6px auto;display:grid;grid-template-columns:repeat(4,1fr);gap:18px}
    .card{max-width:var(--card-w);margin:0 auto}
    .title{font-weight:800;font-size:20px;margin-bottom:4px;display:flex;gap:8px;justify-content:center}
    .sub{font-size:.9em;color:#555}
    .count{font-size:16px;margin:0 0 6px}
    .box{width:var(--box-w);height:var(--box-h);border:2px solid #000;margin:8px auto;border-radius:12px;padding:8px;text-align:left;overflow-y:auto;background:#fff}

    .box .winner-row{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:4px 6px}
    .box .winner-name{flex:1 1 auto;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .box .winner-stats{flex:0 0 auto;color:#6B6620;font-weight:700;white-space:nowrap;text-align:right}

    .card > div:last-of-type > button{font-size:20px;padding:15px 20px;border-radius:20px}
    #copy-btn{font-size:15px;padding:10px 18px;line-height:1;min-width:180px;border-radius:10px}

    /* ===== 오버레이(스피너) ===== */
    #overlay{position:fixed; inset:0; background:rgba(0,0,0,.82); z-index:9999; display:flex; align-items:center; justify-content:center; opacity:0; visibility:hidden; pointer-events:none; transition:opacity .2s ease, visibility 0s linear .2s}
    #overlay.show{opacity:1; visibility:visible; pointer-events:auto; transition:opacity .2s ease}
    #overlay .panel{border-radius:20px; padding:16px 18px; background-image:var(--grad,linear-gradient(135deg,#44D446,#2C472C)); box-shadow:0 18px 50px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06)}
    #overlay .chip{display:inline-block; margin:0 auto 8px; font-weight:800; font-size:12px; letter-spacing:.3px; background:#1b2330; color:#e6edf3; border-radius:999px; padding:6px 10px; text-transform:uppercase}
    #canvasWrap{ position:relative; width:560px; height:200px; border-radius:16px; background:linear-gradient(180deg,#10161c,#0e141a); box-shadow:inset 0 0 0 1px rgba(255,255,255,.06); overflow:hidden}

    @media (max-width: 1200px){ .grid{grid-template-columns:repeat(2,1fr)} }
    @media (max-width: 640px){ .grid{grid-template-columns:repeat(1,1fr)} :root{--box-w: 86vw} }
  </style>
</head>
<body class="notranslate">
  <h2>힙합 랭겜 추첨기</h2>
  <div id="status">⏳ 부팅 중…</div>
  <div id="meta"></div>

  <div class="grid">
    <!-- 언랭 -->
    <div class="card">
      <div class="title"><span>언랭</span><span class="sub">(지원/참여/승리)</span></div>
      <div id="count-언랭" class="count">(당첨: 0명 / 남음: 0명)</div>
      <div id="box-언랭" class="box"></div>
      <div>
        <button id="btn-언랭" onclick="pick('언랭')" disabled>뽑기!</button>
        <button id="reset-언랭" onclick="resetRank('언랭')" disabled>리셋</button>
      </div>
    </div>
    <!-- 브론즈 -->
    <div class="card">
      <div class="title"><span>브론즈</span><span class="sub">(지원/참여/승리)</span></div>
      <div id="count-브론즈" class="count">(당첨: 0명 / 남음: 0명)</div>
      <div id="box-브론즈" class="box"></div>
      <div>
        <button id="btn-브론즈" onclick="pick('브론즈')" disabled>뽑기!</button>
        <button id="reset-브론즈" onclick="resetRank('브론즈')" disabled>리셋</button>
      </div>
    </div>
    <!-- 실버 -->
    <div class="card">
      <div class="title"><span>실버</span><span class="sub">(지원/참여/승리)</span></div>
      <div id="count-실버" class="count">(당첨: 0명 / 남음: 0명)</div>
      <div id="box-실버" class="box"></div>
      <div>
        <button id="btn-실버" onclick="pick('실버')" disabled>뽑기!</button>
        <button id="reset-실버" onclick="resetRank('실버')" disabled>리셋</button>
      </div>
    </div>
    <!-- 골드 -->
    <div class="card">
      <div class="title"><span>골드</span><span class="sub">(지원/참여/승리)</span></div>
      <div id="count-골드" class="count">(당첨: 0명 / 남음: 0명)</div>
      <div id="box-골드" class="box"></div>
      <div>
        <button id="btn-골드" onclick="pick('골드')" disabled>뽑기!</button>
        <button id="reset-골드" onclick="resetRank('골드')" disabled>리셋</button>
      </div>
    </div>
  </div>

  <div style="margin:10px 0 8px;">
    <button id="copy-btn" onclick="copyWinners()" disabled>클립보드로 복사</button>
  </div>

  <!-- 오버레이 -->
  <div id="overlay">
    <div class="panel">
      <div id="tierChip" class="chip"></div>
      <div id="canvasWrap"><canvas id="wheelCanvas" width="560" height="200"></canvas></div>
    </div>
  </div>

<script>
/* =====================
   설정: Google Sheets
   ===================== */
// 업로더 제공 고정 시트 URL에서 ID 추출 (GAS 코드에 명시됨) → "1Lk99MVm...Zee4"
// ref: 고정 시트 & GIF 파일 ID 설정.txt 의 FIXED_SHEET_URL 상수
const SHEET_ID = "1Lk99MVmQQjmS-Xq0Otie-Lu7X5bAjcfmoR_uwXlZee4"; // [filecite placeholder]
// 첫 탭(등급/이름/비고가 있는 시트): gid=0 로 가정
const POOLS_GID = 0;
// 통계(지원/참여/승리) 시트 이름
const STATS_SHEET_NAME = "참여자 리스트"; // [filecite placeholder]

/* =====================
   전역 상태
   ===================== */
const RANKS=['언랭','브론즈','실버','골드'];
let pool   ={언랭:[],브론즈:[],실버:[],골드:[]};
let selected={언랭:[],브론즈:[],실버:[],골드:[]};
let memberStats={};
let siteMeta={sheetName:'', fetchedAt:null};

/* =====================
   helpers (UI)
   ===================== */
const $=id=>document.getElementById(id);
const setStatus=(m,e)=>{const el=$('status'); if(!el) return; el.className=e?'status-err':'status-ok'; el.textContent=m;};
const html=(id,h)=>{const el=$(id); if(el) el.innerHTML=h;};
const append=(id,h)=>{const el=$(id); if(el) el.insertAdjacentHTML('beforeend',h);};
const dis=(id,v)=>{const el=$(id); if(el) el.disabled=!!v;};
const esc=s=>String(s).replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
function labelOf(v){ if(v==null) return ''; if(typeof v==='string'||typeof v==='number') return String(v); if(Array.isArray(v)) return String(v[0]??''); if(typeof v==='object') return String(v.name??v['이름']??v.label??''); return String(v); }

/* =====================
   gviz fetch & parse
   ===================== */
function gvizUrlByGid(id,gid){ return `https://docs.google.com/spreadsheets/d/${id}/gviz/tq?gid=${gid}&tqx=out:json`; }
function gvizUrlBySheet(id,sheet){ const sn=encodeURIComponent(sheet); return `https://docs.google.com/spreadsheets/d/${id}/gviz/tq?sheet=${sn}&tqx=out:json`; }
async function fetchGvizJSON(url){
  const res=await fetch(url,{cache:'no-store'});
  if(!res.ok) throw new Error(`HTTP ${res.status}`);
  const txt=await res.text();
  // 응답은 JS 콜백 래퍼로 감싸져 있음 → JSON 부분만 추출
  const m=txt.match(/setResponse\((.*)\);?\s*$/s);
  if(!m) throw new Error('gviz parse 실패');
  return JSON.parse(m[1]);
}
function parseGvizTable(obj){
  // obj.table.cols: [{label,type},...], obj.table.rows: [{c:[{v, f?}, ...]}, ...]
  const cols=(obj?.table?.cols||[]).map(c=>String(c?.label||'').trim().toLowerCase());
  const rows=(obj?.table?.rows||[]).map(r=> (r?.c||[]).map(c=> (c?.v!=null? String(c.v): '').trim()) );
  return { cols, rows };
}
function _norm(v){ return String(v||'').replace(/\u00A0/g,' ').replace(/\s+/g,' ').trim(); }
function parseCount(v){ const s=String(v||'').trim().replace(/회\s*$/i,''); const n=parseInt(s,10); return isNaN(n)?0:n; }

/* =====================
   시트 → 데이터 매핑 (GAS 로직을 JS로 이식)
   ===================== */
function normalizeRank_(s){
  s=_norm(s).toLowerCase();
  if(/언랭|unrank/.test(s)) return '언랭';
  if(/브론즈|bronze/.test(s)) return '브론즈';
  if(/실버|silver/.test(s)) return '실버';
  if(/골드|gold/.test(s)) return '골드';
  return '';
}
function findHeaderIndex_(header, keywords){
  header=header.map(h=>_norm(h).toLowerCase());
  for(let i=0;i<header.length;i++) for(let k=0;k<keywords.length;k++) if(header[i]===keywords[k].toLowerCase()) return i;
  return -1;
}
function buildPoolsFromGviz(obj){
  const {cols, rows}=parseGvizTable(obj);
  const pools={ '언랭':[], '브론즈':[], '실버':[], '골드':[] };
  const remarks={};
  const idxRank=findHeaderIndex_(cols,['등급','랭크','rank']);
  const idxName=findHeaderIndex_(cols,['이름','name']);
  const idxNote=findHeaderIndex_(cols,['비고','메모','remark','note']);
  for(const row of rows){
    const name=_norm(idxName>=0? row[idxName]: row[0]);
    if(!name) continue;
    const rankRaw=_norm(idxRank>=0? row[idxRank]: '');
    const rank=normalizeRank_(rankRaw);
    if(rank && pools[rank] && pools[rank].indexOf(name)===-1) pools[rank].push(name);
    if(idxNote>=0){ const note=_norm(row[idxNote]); if(note) remarks[name]=note; }
  }
  return {pools, remarks};
}
function buildStatsFromGviz(obj){
  const {cols, rows}=parseGvizTable(obj);
  const idxName=findHeaderIndex_(cols,['이름','name']);
  const idxApply=findHeaderIndex_(cols,['지원','apply']);
  const idxPart =findHeaderIndex_(cols,['참여','part']);
  const idxWin  =findHeaderIndex_(cols,['승리','win']);
  const stats={};
  for(const row of rows){
    const name=_norm(idxName>=0? row[idxName]: row[0]);
    if(!name) continue;
    stats[name]={
      apply: parseCount(idxApply>=0? row[idxApply]:0),
      part : parseCount(idxPart >=0? row[idxPart ]:0),
      win  : parseCount(idxWin  >=0? row[idxWin  ]:0)
    };
  }
  return stats;
}

/* =====================
   스피너/오버레이 (기존 유지)
   ===================== */
function gradByRank(rank){ switch(rank){ case '브론즈': return 'linear-gradient(135deg,#968768,#524937)'; case '실버': return 'linear-gradient(135deg,#BABABA,#616060)'; case '골드': return 'linear-gradient(135deg,#D1C432,#827810)'; default: return 'linear-gradient(135deg,#44D446,#2C472C)'; } }
function setupCanvas(canvas){ const dpr=Math.max(1,window.devicePixelRatio||1); const rect=canvas.getBoundingClientRect(); canvas.style.width=rect.width+'px'; canvas.style.height=rect.height+'px'; canvas.width=Math.round(rect.width*dpr); canvas.height=Math.round(rect.height*dpr); const ctx=canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0); ctx.imageSmoothingEnabled=true; return { ctx, w:rect.width, h:rect.height }; }
function drawName(ctx, text, cx, cy, maxW, targetH, weight=900){ let lo=14, hi=Math.min(targetH,64), best=lo; ctx.save(); ctx.textBaseline='middle'; ctx.textAlign='center'; ctx.direction='ltr'; ctx.shadowOffsetX=0; ctx.shadowOffsetY=0; while(lo<=hi){ const mid=(lo+hi)>>1; ctx.font=`normal ${weight} ${mid}px Arial, \"Noto Sans KR\", sans-serif`; const w=ctx.measureText(text).width; if(w<=maxW){best=mid; lo=mid+1;} else hi=mid-1; } ctx.font=`normal ${weight} ${best}px Arial, \"Noto Sans KR\", sans-serif`; const x=Math.round(cx)+0.5, y=Math.round(cy)+0.5; ctx.fillText(text,x,y); ctx.restore(); }
let LAST_SPIN_MODE=null; function pickStopMode(){ const modes=['exact','nudgeForward','nudgeBackward']; let m=modes[Math.floor(Math.random()*modes.length)]; if(m===LAST_SPIN_MODE) m=modes[(modes.indexOf(m)+1)%modes.length]; LAST_SPIN_MODE=m; return m; }
function canvasSpin(names, winner, opts, onDone){ const overlay=$('overlay'); const canvas=$('wheelCanvas'); const { ctx, w, h }=setupCanvas(canvas); const centerY=h/2; const rowH=opts.rowH||40, gap=opts.gap||12, step=rowH+gap; const accelMs=opts.accelMs??500, steadyMs=opts.steadyMs??900, decelMs=opts.decelMs??1100; const shakeMs=260, nudgeMs=300, shakeAmp=8; const easeOutCubic=t=>1-Math.pow(1-t,3); const L=Math.max(1,names.length); const startIdx=Math.floor(Math.random()*L); const winIdx=names.indexOf(winner); const mode=pickStopMode(); let preIdx=winIdx, nudgeDir=0; if(mode==='nudgeForward'){ preIdx=(winIdx-1+L)%L; nudgeDir=+1; } if(mode==='nudgeBackward'){ preIdx=(winIdx+1)%L;  nudgeDir=-1; } const cycles=4; const idxDiffPre=((preIdx-startIdx)%L+L)%L; const baseTotalShift=(cycles*L+idxDiffPre)*step; const spinTotal=accelMs+steadyMs+decelMs; const extraTotal=(nudgeDir===0?0:(shakeMs+nudgeMs)); function drawCenterGuides(){ ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.18)'; ctx.lineWidth=1; const pad=12, yA=Math.round(centerY-step/2)+0.5, yB=Math.round(centerY+step/2)+0.5; ctx.beginPath(); ctx.moveTo(pad,yA); ctx.lineTo(w-pad,yA); ctx.moveTo(pad,yB); ctx.lineTo(w-pad,yB); ctx.stroke(); ctx.restore(); } function renderFrame(now, t0){ const t=now-t0; let dist=0; if(t<=spinTotal){ if(t<=accelMs){ const k=t/accelMs; dist=baseTotalShift*(k*0.2); } else if(t<=accelMs+steadyMs){ const k=(t-accelMs)/steadyMs; dist=baseTotalShift*(0.2+0.5*k); } else { const k=(t-accelMs-steadyMs)/decelMs; dist=baseTotalShift*(0.7+0.3*easeOutCubic(Math.min(1,k))); } } else if(nudgeDir!==0 && t<=spinTotal+shakeMs){ const k=(t-spinTotal)/shakeMs; dist=baseTotalShift+Math.sin(k*Math.PI*2.0)*shakeAmp; } else if(nudgeDir!==0 && t<=spinTotal+shakeMs+nudgeMs){ const k=(t-spinTotal-shakeMs)/nudgeMs; dist=baseTotalShift+(nudgeDir*step)*easeOutCubic(Math.min(1,k)); } else { dist=baseTotalShift+(nudgeDir*step); } ctx.clearRect(0,0,w,h); const shiftRows=dist/step, baseIdx=Math.floor(shiftRows), frac=shiftRows-baseIdx; for(let k=-3;k<=+3;k++){ const idx=(startIdx+baseIdx+k+L)%L; const name=names[idx]; const y=centerY-(k-frac)*step; const ady=Math.abs(k-frac); let scale=0.6, alpha=0.45; if(ady<=0.5){ scale=1.0; alpha=1.0; } else if(ady<=1.5){ scale=0.8; alpha=0.75; } ctx.save(); ctx.globalAlpha=alpha; if(scale>=0.95){ ctx.shadowColor='rgba(0,0,0,0.55)'; ctx.shadowBlur=10; ctx.shadowOffsetY=3; } else { ctx.shadowColor='transparent'; ctx.shadowBlur=0; ctx.shadowOffsetY=0; } ctx.fillStyle='#fff'; drawName(ctx, name, w/2, y, w*0.86, rowH*scale, 900); ctx.restore(); } drawCenterGuides(); const endTime=spinTotal+extraTotal; if(t<endTime){ requestAnimationFrame(n2=>renderFrame(n2,t0)); } else { setTimeout(()=>{ overlay.classList.remove('show'); onDone&&onDone(); }, opts.waitMs ?? 1800); } } requestAnimationFrame(t0=>renderFrame(t0,t0)); }
function showOverlayWithName(rank, winner, done){ const names=(pool[rank]||[]).map(labelOf).map(s=>String(s||'').trim()).filter(Boolean); $('overlay').style.setProperty('--grad', gradByRank(rank)); $('tierChip').textContent=(rank==='브론즈'?'BRONZE':rank==='실버'?'SILVER':rank==='골드'?'GOLD':rank); $('overlay').classList.add('show'); canvasSpin(names.length?names:[winner], String(winner), { accelMs: 500, steadyMs: 900, decelMs: 1100, rowH: 40, gap: 12, waitMs: 1800 }, done); }

/* =====================
   pick/reset & 카운터/복사
   ===================== */
function fmtStats(name){ const st = memberStats && memberStats[name] ? memberStats[name] : {apply:0, part:0, win:0}; const a = Number(st.apply)||0, p=Number(st.part)||0, w=Number(st.win)||0; return `${a}/${p}/${w}`; }
function renderRow(name){ const safe=esc(name); return `<div class=\"winner-row\"><span class=\"winner-name\"><b>${safe}</b></span><span class=\"winner-stats\">(${fmtStats(name)})</span></div>`; }
function updateCounts(rank){ const picked=(selected[rank]||[]).length; const remain=Math.max(0,(pool[rank]?.length||0)-picked); html('count-'+rank,`(당첨: ${picked}명 / 남음: ${remain}명)`); }
function totalWinners(){return RANKS.reduce((s,r)=>s+(selected[r]?.length||0),0)}
function copyWinners(){ if(totalWinners()===0){ setStatus('복사할 당첨자가 없습니다.',true); return; } const lines=[]; for(const r of RANKS){ const arr=selected[r]||[]; if(!arr.length) continue; lines.push(r,'------------',...arr.map(n=>`${n} (${fmtStats(n)})`),''); } const txt=lines.join('\n').trim(); if(navigator.clipboard?.writeText){ navigator.clipboard.writeText(txt).then(()=>setStatus('✅ 복사 완료',false)).catch(()=>alert(txt)); } else alert(txt); }
function pick(rank){ try{ const btn=$('btn-'+rank); if(!btn||btn.disabled) return; btn.disabled=true; const remain=(pool[rank]||[]).map(labelOf).filter(n=>n && !(selected[rank]||[]).includes(n)); if(!remain.length){ setStatus(`⚠️ ${rank} 인원이 없습니다.`,true); btn.disabled=false; return; } const winner=remain[Math.floor(Math.random()*remain.length)]; showOverlayWithName(rank, winner, ()=>{ (selected[rank]=selected[rank]||[]).push(winner); append('box-'+rank, renderRow(winner)); updateCounts(rank); const still=(pool[rank]?.length||0)-(selected[rank]?.length||0); btn.disabled=(still===0); dis('copy-btn', totalWinners()===0); setStatus(`${rank} → ${winner} 당첨!`, false); }); }catch(e){ setStatus('❌ pick 오류: '+e,true); } }
function resetRank(rank){ selected[rank]=[]; html('box-'+rank,''); updateCounts(rank); dis('btn-'+rank,(pool[rank]?.length||0)===0); dis('copy-btn', totalWinners()===0); setStatus(`${rank} 리셋 완료`, false); }
function preReset(){ setStatus('⏳ 부팅 중…',false); $('meta').textContent=''; for(const r of RANKS){ html('box-'+r,''); html('count-'+r,'(당첨: 0명 / 남음: 0명)'); dis('btn-'+r,true); dis('reset-'+r,true); } dis('copy-btn',true); }

/* =====================
   부팅: 시트에서 데이터 읽기
   ===================== */
async function loadFromSheets(){
  try{
    // 1) 첫 탭(POOLS) — gid=0
    const poolsObj = await fetchGvizJSON( gvizUrlByGid(SHEET_ID, POOLS_GID) );
    const {pools, remarks} = buildPoolsFromGviz(poolsObj);

    // 2) 통계 탭(STATS)
    let stats={};
    try{ const statsObj = await fetchGvizJSON( gvizUrlBySheet(SHEET_ID, STATS_SHEET_NAME) ); stats = buildStatsFromGviz(statsObj); }
    catch{ stats={}; }

    pool = pools; memberStats = stats; selected={언랭:[],브론즈:[],실버:[],골드:[]};
    for(const r of RANKS){ const remain=(pool[r]||[]).length; html('count-'+r,`(당첨: 0명 / 남음: ${remain}명)`); dis('btn-'+r, remain===0); dis('reset-'+r,false); }
    dis('copy-btn',true);

    // 메타 표기: 문서명은 gviz에서 직접 제공하지 않으므로 fetchedAt만 표기
    siteMeta.fetchedAt=Date.now(); $('meta').textContent = new Date(siteMeta.fetchedAt).toLocaleString();
    setStatus('✅ 준비 완료 (Google Sheets)', false);
  }catch(e){
    if(String(e.message||e).includes('HTTP 403')){
      setStatus('❌ 시트 접근 거부(403). 파일→웹에 게시했는지 확인하세요.', true);
    }else{
      setStatus('❌ 시트 로드 실패: '+ (e.message||e), true);
    }
  }
}

document.addEventListener('DOMContentLoaded', ()=>{ preReset(); loadFromSheets(); });
</script>
</body>
</html>


